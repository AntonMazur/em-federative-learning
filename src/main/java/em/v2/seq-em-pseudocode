Входные данные:
    n - количество входных данных
    data[n] - кластеризуемые данные
    k - количество кластеров
    stop - условие остановки алгоритма(достижение заданной точности кластеризаци или заданного количества итераций)
Инициализация:
    gamma[n, k], gamma[i, j] = 0 for i = 0..n-1, j = 0..k-1 - матрица скрытых переменных
    mean[k], mean[j] = Random for j = 0..k-1  - мат.ожидания гауссиан, описывающих кластера
    cov[k], cov[j] = I for j = 0..k-1 - матрицы ковариации гауссиан, описывающие кластера
    weight[k], weight[j] = 1/k j = 0..k-1 - априорные вероятности принадлежности наблюдений к кластерам
    clustProb[k]
while (!stop)
    // e-step
    for i = 0..n-1
        instanceProb = 0
        for j = 0..k-1
            instanceProb = instanceProb + weight[j] * p(data[i,j], mean[j], cov[j])
        for j = 0..k-1
            gamma[i, j] = weight[j] * p(data[i,j]) / instanceProb

    // m - step

    for j = 0..k-1
        clustProb[j] = 0
        mean[j] = 0

        for i = 0..n-1
            clustProb[j] = clustProb[j] + gamma[i, j]
            mean[j] = mean[j] + gamma[i, j] * data[i]

        mean[j] = mean[j] / clustProb

    for j = 0..k-1
        cov[j] = 0

        for i = 0..n-1
            cov[j] = gamma[i, j] * (data[i, j] - mean[j]) * transpose((data[i, j] - mean[j]))

        cov[j] = cov[j] / clustProb[j]
        weight[j] = clustProb[j] / n






